/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * quadcopter_model.c
 *
 * Code generation for function 'quadcopter_model'
 *
 */

/* Include files */
#include "quadcopter_model.h"
#include <emmintrin.h>
#include <math.h>

/* Function Definitions */
void quadcopter_model(const double x[12], const double u[4], double dxdt[12])
{
  static const double b_a[9] = {0.1, 0.0, 0.0, 0.0, 0.1, 0.0, 0.0, 0.0, 0.2};
  static const double dv[3] = {0.0, 0.0, 9.81};
  static const signed char c_a[9] = {10, 0, 0, 0, 10, 0, 0, 0, 5};
  double c_R_y_tmp[9];
  double c_R_z_tmp[9];
  double d_R_z_tmp[9];
  double accel[3];
  double angular_acc[3];
  double b_u[3];
  double y[3];
  double R_x_tmp;
  double R_y_tmp;
  double R_z_tmp;
  double a;
  double b_R_x_tmp;
  double b_R_y_tmp;
  double b_R_z_tmp;
  double d;
  int R_z_tmp_tmp;
  int i;
  int i1;
  /*  Parameters of the quadcopter */
  /*  Mass of the quadcopter (kg) */
  /*  Gravity (m/s^2) */
  /*  Inertia matrix (kg*m^2) */
  /*  Distance from center of mass to motors (m) */
  /*  Thrust constant (N per unit input) */
  /*  Moment constant (N*m per unit input) */
  /*  Quadcopter state vector */
  /*  Position (x, y, z) */
  /*  Velocity (vx, vy, vz) */
  /*  Euler angles (phi, theta, psi) */
  /*  Angular velocity (wx, wy, wz) */
  /*  Rotation matrix (from global frame to body frame) */
  /*  Function to convert Euler angles to rotation matrix */
  /*  Roll */
  /*  Pitch */
  /*  Yaw */
  /*  Rotation matrix about x-axis (roll) */
  R_x_tmp = sin(x[6]);
  b_R_x_tmp = cos(x[6]);
  /*  Rotation matrix about y-axis (pitch) */
  R_y_tmp = sin(x[7]);
  b_R_y_tmp = cos(x[7]);
  /*  Rotation matrix about z-axis (yaw) */
  R_z_tmp = sin(x[8]);
  b_R_z_tmp = cos(x[8]);
  /*  Combined rotation matrix: R = Rz * Ry * Rx */
  /*  Motor forces (thrust and torques) */
  /*  Thrust from motor 1 */
  /*  Thrust from motor 2 */
  /*  Thrust from motor 3 */
  /*  Thrust from motor 4 */
  /*  Compute total thrust from all motors */
  a = ((u[0] + u[1]) + u[2]) + u[3];
  /*  Total thrust force */
  /*  Compute torques generated by the motors */
  /*  Roll torque */
  /*  Pitch torque */
  /*  Yaw torque */
  /*  Total thrust force vector in world frame (aligned with body z-axis) */
  /*  Thrust direction (z-axis of body) */
  /*  Translational dynamics (acceleration) */
  c_R_z_tmp[0] = b_R_z_tmp;
  c_R_z_tmp[3] = -R_z_tmp;
  c_R_z_tmp[6] = 0.0;
  c_R_z_tmp[1] = R_z_tmp;
  c_R_z_tmp[4] = b_R_z_tmp;
  c_R_z_tmp[7] = 0.0;
  c_R_y_tmp[0] = b_R_y_tmp;
  c_R_y_tmp[3] = 0.0;
  c_R_y_tmp[6] = R_y_tmp;
  c_R_z_tmp[2] = 0.0;
  c_R_y_tmp[1] = 0.0;
  c_R_z_tmp[5] = 0.0;
  c_R_y_tmp[4] = 1.0;
  c_R_z_tmp[8] = 1.0;
  c_R_y_tmp[7] = 0.0;
  c_R_y_tmp[2] = -R_y_tmp;
  c_R_y_tmp[5] = 0.0;
  c_R_y_tmp[8] = b_R_y_tmp;
  for (i = 0; i < 3; i++) {
    b_R_z_tmp = c_R_z_tmp[i];
    d = c_R_z_tmp[i + 3];
    i1 = (int)c_R_z_tmp[i + 6];
    for (R_z_tmp_tmp = 0; R_z_tmp_tmp < 3; R_z_tmp_tmp++) {
      d_R_z_tmp[i + 3 * R_z_tmp_tmp] =
          (b_R_z_tmp * c_R_y_tmp[3 * R_z_tmp_tmp] +
           d * c_R_y_tmp[3 * R_z_tmp_tmp + 1]) +
          (double)i1 * c_R_y_tmp[3 * R_z_tmp_tmp + 2];
    }
  }
  c_R_y_tmp[0] = 1.0;
  c_R_y_tmp[3] = 0.0;
  c_R_y_tmp[6] = 0.0;
  c_R_y_tmp[1] = 0.0;
  c_R_y_tmp[4] = b_R_x_tmp;
  c_R_y_tmp[7] = -R_x_tmp;
  c_R_y_tmp[2] = 0.0;
  c_R_y_tmp[5] = R_x_tmp;
  c_R_y_tmp[8] = b_R_x_tmp;
  /*  Acceleration = thrust/mass - gravity */
  /*  Rotational dynamics (angular acceleration) */
  b_u[0] = u[1] - u[3];
  b_u[1] = u[2] - u[0];
  b_u[2] = ((u[0] - u[1]) + u[2]) - u[3];
  for (i = 0; i < 3; i++) {
    b_R_z_tmp = d_R_z_tmp[i];
    d = d_R_z_tmp[i + 3];
    R_y_tmp = d_R_z_tmp[i + 6];
    b_R_y_tmp = 0.0;
    R_z_tmp = 0.0;
    for (i1 = 0; i1 < 3; i1++) {
      R_z_tmp_tmp = i + 3 * i1;
      c_R_z_tmp[R_z_tmp_tmp] =
          (b_R_z_tmp * c_R_y_tmp[3 * i1] + d * c_R_y_tmp[3 * i1 + 1]) +
          R_y_tmp * c_R_y_tmp[3 * i1 + 2];
      b_R_y_tmp += b_a[R_z_tmp_tmp] * x[i1 + 9];
      R_z_tmp += (double)c_a[R_z_tmp_tmp] * b_u[i1];
    }
    angular_acc[i] = R_z_tmp;
    y[i] = b_R_y_tmp;
    accel[i] = a * c_R_z_tmp[i + 6] / 1.5 - dv[i];
  }
  __m128d r;
  __m128d r1;
  b_u[0] = y[2] * x[10] - y[1] * x[11];
  b_u[1] = y[0] * x[11] - y[2] * x[9];
  b_u[2] = y[1] * x[9] - y[0] * x[10];
  r = _mm_loadu_pd(&angular_acc[0]);
  r1 = _mm_loadu_pd(&b_u[0]);
  _mm_storeu_pd(&angular_acc[0], _mm_sub_pd(r, r1));
  angular_acc[2] -= b_u[2];
  /*  Angular acceleration = torque/inertia - gyroscopic effects */
  /*  Compute state derivatives */
  /*  Derivative of position is velocity */
  /*  Derivative of velocity is acceleration */
  /*  Derivative of Euler angles is angular velocity */
  dxdt[0] = x[3];
  dxdt[3] = accel[0];
  dxdt[6] = x[9];
  dxdt[9] = angular_acc[0];
  dxdt[1] = x[4];
  dxdt[4] = accel[1];
  dxdt[7] = x[10];
  dxdt[10] = angular_acc[1];
  dxdt[2] = x[5];
  dxdt[5] = accel[2];
  dxdt[8] = x[11];
  dxdt[11] = angular_acc[2];
  /*  Derivative of angular velocity is angular acceleration */
}

/* End of code generation (quadcopter_model.c) */
